// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Geek Budget - OpenAPI 3.0
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 0.0.1
 * Contact: ilya.korolev@outlook.com
 */

package goserver

import (
	"encoding/json"
	"net/http"
	"os"
	"strings"

	"github.com/gorilla/mux"
)

// MatchersAPIController binds http requests to an api service and writes the service results to the http response
type MatchersAPIController struct {
	service      MatchersAPIServicer
	errorHandler ErrorHandler
}

// MatchersAPIOption for how the controller is set up.
type MatchersAPIOption func(*MatchersAPIController)

// WithMatchersAPIErrorHandler inject ErrorHandler into controller
func WithMatchersAPIErrorHandler(h ErrorHandler) MatchersAPIOption {
	return func(c *MatchersAPIController) {
		c.errorHandler = h
	}
}

// NewMatchersAPIController creates a default api controller
func NewMatchersAPIController(s MatchersAPIServicer, opts ...MatchersAPIOption) *MatchersAPIController {
	controller := &MatchersAPIController{
		service:      s,
		errorHandler: DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the MatchersAPIController
func (c *MatchersAPIController) Routes() Routes {
	return Routes{
		"GetMatchers": Route{
			strings.ToUpper("Get"),
			"/v1/matchers",
			c.GetMatchers,
		},
		"CreateMatcher": Route{
			strings.ToUpper("Post"),
			"/v1/matchers",
			c.CreateMatcher,
		},
		"GetMatcher": Route{
			strings.ToUpper("Get"),
			"/v1/matchers/{id}",
			c.GetMatcher,
		},
		"UpdateMatcher": Route{
			strings.ToUpper("Put"),
			"/v1/matchers/{id}",
			c.UpdateMatcher,
		},
		"DeleteMatcher": Route{
			strings.ToUpper("Delete"),
			"/v1/matchers/{id}",
			c.DeleteMatcher,
		},
		"UploadMatcherImage": Route{
			strings.ToUpper("Post"),
			"/v1/matchers/{id}/image",
			c.UploadMatcherImage,
		},
		"DeleteMatcherImage": Route{
			strings.ToUpper("Delete"),
			"/v1/matchers/{id}/image",
			c.DeleteMatcherImage,
		},
		"CheckRegex": Route{
			strings.ToUpper("Post"),
			"/v1/matchers/check-regex",
			c.CheckRegex,
		},
		"CheckMatcher": Route{
			strings.ToUpper("Post"),
			"/v1/matchers/check",
			c.CheckMatcher,
		},
	}
}

// GetMatchers - get all matchers
func (c *MatchersAPIController) GetMatchers(w http.ResponseWriter, r *http.Request) {
	result, err := c.service.GetMatchers(r.Context())
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// CreateMatcher - create new matcher
func (c *MatchersAPIController) CreateMatcher(w http.ResponseWriter, r *http.Request) {
	matcherNoIdParam := MatcherNoId{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&matcherNoIdParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertMatcherNoIdRequired(matcherNoIdParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertMatcherNoIdConstraints(matcherNoIdParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.CreateMatcher(r.Context(), matcherNoIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetMatcher - get matcher
func (c *MatchersAPIController) GetMatcher(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	result, err := c.service.GetMatcher(r.Context(), idParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// UpdateMatcher - update matcher
func (c *MatchersAPIController) UpdateMatcher(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	matcherNoIdParam := MatcherNoId{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&matcherNoIdParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertMatcherNoIdRequired(matcherNoIdParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertMatcherNoIdConstraints(matcherNoIdParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.UpdateMatcher(r.Context(), idParam, matcherNoIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// DeleteMatcher - delete matcher
func (c *MatchersAPIController) DeleteMatcher(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	result, err := c.service.DeleteMatcher(r.Context(), idParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// UploadMatcherImage - Upload matcher image
func (c *MatchersAPIController) UploadMatcherImage(w http.ResponseWriter, r *http.Request) {
	if err := r.ParseMultipartForm(32 << 20); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	params := mux.Vars(r)
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	var fileParam *os.File
	{
		param, err := ReadFormFileToTempFile(r, "file")
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "file", Err: err}, nil)
			return
		}

		fileParam = param
	}
	if fileParam != nil {
		defer fileParam.Close()
	}

	result, err := c.service.UploadMatcherImage(r.Context(), idParam, fileParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// DeleteMatcherImage - delete matcher image
func (c *MatchersAPIController) DeleteMatcherImage(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	result, err := c.service.DeleteMatcherImage(r.Context(), idParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// CheckRegex - check if regex is valid and matches string (using backend's regex engine)
func (c *MatchersAPIController) CheckRegex(w http.ResponseWriter, r *http.Request) {
	checkRegexRequestParam := CheckRegexRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&checkRegexRequestParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertCheckRegexRequestRequired(checkRegexRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertCheckRegexRequestConstraints(checkRegexRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.CheckRegex(r.Context(), checkRegexRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// CheckMatcher - check if passed matcher matches given transaction
func (c *MatchersAPIController) CheckMatcher(w http.ResponseWriter, r *http.Request) {
	checkMatcherRequestParam := CheckMatcherRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&checkMatcherRequestParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertCheckMatcherRequestRequired(checkMatcherRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertCheckMatcherRequestConstraints(checkMatcherRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.CheckMatcher(r.Context(), checkMatcherRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}
