// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Geek Budget - OpenAPI 3.0
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 0.0.1
 * Contact: ilya.korolev@outlook.com
 */

package goserver

import (
	"encoding/json"
	"net/http"
	"strings"
	"time"

	"github.com/gorilla/mux"
	"github.com/shopspring/decimal"
)

// TransactionsAPIController binds http requests to an api service and writes the service results to the http response
type TransactionsAPIController struct {
	service      TransactionsAPIServicer
	errorHandler ErrorHandler
}

// TransactionsAPIOption for how the controller is set up.
type TransactionsAPIOption func(*TransactionsAPIController)

// WithTransactionsAPIErrorHandler inject ErrorHandler into controller
func WithTransactionsAPIErrorHandler(h ErrorHandler) TransactionsAPIOption {
	return func(c *TransactionsAPIController) {
		c.errorHandler = h
	}
}

// NewTransactionsAPIController creates a default api controller
func NewTransactionsAPIController(s TransactionsAPIServicer, opts ...TransactionsAPIOption) *TransactionsAPIController {
	controller := &TransactionsAPIController{
		service:      s,
		errorHandler: DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the TransactionsAPIController
func (c *TransactionsAPIController) Routes() Routes {
	return Routes{
		"GetTransactions": Route{
			strings.ToUpper("Get"),
			"/v1/transactions",
			c.GetTransactions,
		},
		"CreateTransaction": Route{
			strings.ToUpper("Post"),
			"/v1/transactions",
			c.CreateTransaction,
		},
		"GetTransaction": Route{
			strings.ToUpper("Get"),
			"/v1/transactions/{id}",
			c.GetTransaction,
		},
		"UpdateTransaction": Route{
			strings.ToUpper("Put"),
			"/v1/transactions/{id}",
			c.UpdateTransaction,
		},
		"DeleteTransaction": Route{
			strings.ToUpper("Delete"),
			"/v1/transactions/{id}",
			c.DeleteTransaction,
		},
		"MergeTransactions": Route{
			strings.ToUpper("Post"),
			"/v1/transactions/merge",
			c.MergeTransactions,
		},
	}
}

// GetTransactions - get all transactions which matches given filters
func (c *TransactionsAPIController) GetTransactions(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var descriptionParam string
	if query.Has("description") {
		param := query.Get("description")

		descriptionParam = param
	} else {
	}
	var amountFromParam decimal.Decimal
	if query.Has("amountFrom") {
		param, err := parseNumericParameter[decimal.Decimal](
			query.Get("amountFrom"),
			WithParse[decimal.Decimal](parseDecimal),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "amountFrom", Err: err}, nil)
			return
		}

		amountFromParam = param
	} else {
	}
	var amountToParam decimal.Decimal
	if query.Has("amountTo") {
		param, err := parseNumericParameter[decimal.Decimal](
			query.Get("amountTo"),
			WithParse[decimal.Decimal](parseDecimal),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "amountTo", Err: err}, nil)
			return
		}

		amountToParam = param
	} else {
	}
	var dateFromParam time.Time
	if query.Has("dateFrom") {
		param, err := parseTime(query.Get("dateFrom"))
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "dateFrom", Err: err}, nil)
			return
		}

		dateFromParam = param
	} else {
	}
	var dateToParam time.Time
	if query.Has("dateTo") {
		param, err := parseTime(query.Get("dateTo"))
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "dateTo", Err: err}, nil)
			return
		}

		dateToParam = param
	} else {
	}
	var onlySuspiciousParam bool
	if query.Has("onlySuspicious") {
		param, err := parseBoolParameter(
			query.Get("onlySuspicious"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "onlySuspicious", Err: err}, nil)
			return
		}

		onlySuspiciousParam = param
	} else {
		var param bool = false
		onlySuspiciousParam = param
	}
	result, err := c.service.GetTransactions(r.Context(), descriptionParam, amountFromParam, amountToParam, dateFromParam, dateToParam, onlySuspiciousParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// CreateTransaction - create new transaction
func (c *TransactionsAPIController) CreateTransaction(w http.ResponseWriter, r *http.Request) {
	transactionNoIdParam := TransactionNoId{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&transactionNoIdParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertTransactionNoIdRequired(transactionNoIdParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertTransactionNoIdConstraints(transactionNoIdParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.CreateTransaction(r.Context(), transactionNoIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetTransaction - get transaction
func (c *TransactionsAPIController) GetTransaction(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	result, err := c.service.GetTransaction(r.Context(), idParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// UpdateTransaction - update transaction
func (c *TransactionsAPIController) UpdateTransaction(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	transactionNoIdParam := TransactionNoId{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&transactionNoIdParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertTransactionNoIdRequired(transactionNoIdParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertTransactionNoIdConstraints(transactionNoIdParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.UpdateTransaction(r.Context(), idParam, transactionNoIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// DeleteTransaction - delete transaction
func (c *TransactionsAPIController) DeleteTransaction(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	result, err := c.service.DeleteTransaction(r.Context(), idParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// MergeTransactions - merge two transactions
func (c *TransactionsAPIController) MergeTransactions(w http.ResponseWriter, r *http.Request) {
	mergeTransactionsRequestParam := MergeTransactionsRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&mergeTransactionsRequestParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertMergeTransactionsRequestRequired(mergeTransactionsRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertMergeTransactionsRequestConstraints(mergeTransactionsRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.MergeTransactions(r.Context(), mergeTransactionsRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}
